<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>la font</title>
		<link rel="stylesheet" href="asset/css/style.css">
	</head>

	<body>
			<div class="navbar-top">
				<a href="index.html" class="logo">Font</a>
				<a name="arrow" class="home" href="../../">Indietro</a>
			</div>

			<div class="navbar-bottom">
				<ul id="menu">
					<li><a href="#storia">Storia</a> •</li>
					<li><a href="#computer">Computer fonts</a> •</li>
					<li><a href="#bitmap">Bitmap font</a> •</li>
					<li><a href="#vector">Vector font</a> •</li>
					<li><a href="#stroke">Stroke font</a></li>
				</ul>
			</div>
			

			<div class="capitolo-etimologia">
				<p class="testo-etimologia">
				 Il termine inglese font, precedentemente fount, deriva probabilmente dal francese medievale fonte, che significa fuso. Il termine lettering identifica la fase di elaborazione di un’artefatto grafico che adopera una o più font. Oggi si definisce l’insieme dei caratteri, dei glifi e dei segni di interpunzione che compongono la font digitale.</p>	
			</div>	

				<hr class="hr5px">

			<div class="indice">
				<p class="testo-indice">Indice</p>
			</div>	

				<hr class="hr1px">

			<!-- open capitolo-storia -->

			<div class="capitolo"> 
					<a name="storia">
						<p class="titolo-capitolo" id="titolo_storia">Storia</p>
					</a>
						<div class="testo-capitolo" id="testo_storia">
							<div class="titolo-testo-capitolo">
								<p>Cenni storici</p>
							</div>
							<div class="paragrafo-testo-capitolo">
								<p>Quando si parla di caratteri o tipi, intesi come mobili, bisogna risalire al periodo di Gutenberg: si tratta di palelepidi metallici detti “blocchi” o “tipi” che presentano su di un lato il singolo glifo, inteso come alfabeto tipografico, minuscolo, maiuscolo, punti di interpunzione, in diversi corpi.
								<br>
								<br>	
								Il primo carattere mobile, il Textura, fu inventato dallo stesso Gutenberg e utilizzato per comporre la Bibbia a 42 linee (B42) disposte su due colonne - contando quindi 42 righe di testo per colonna - l’opera fu realizzata in tre anni, dal 1452 al 1455. Con l’evoluzione della stampa è progredita in parallelo anche l’evoluzione e la progettazione dei caratteri fino a tutto il XX secolo, quando, con l’avvento del Desktop Publishing, è cambiato il sistema di progettazione dall’analogia al digitale. Oggi le font vengono progettate al computer con software di Type design e distribuite in formati digitali. Esistono innumerevoli caratteri presenti nel mercato, distribuiti da fondere digitali, che permettono una scelta in base alla classificazione, ai pesi e alla leggibilità.
								Il type design è la disciplina che si occupa delle font; il type designer è colui che progetta le font, che ha sostituito la figura di disegnatore di caratteri tipografici.</p>
							</div>	
						</div>	
			</div>

				<!-- close capitolo-storia -->

				<hr class="hr1px">

				<!-- open capitolo-computer -->

			<div class="capitolo"> 
				<a name="computer">	
					<p class="titolo-capitolo" id="titolo_computer_fonts">Computer fonts</p>
				</a>
						<div class="testo-capitolo" id="testo_computer_fonts">
							<div class="titolo-testo-capitolo">
								<p>I file digitali</p>
							</div>
							<div class="paragrafo-testo-capitolo">
								<p>All’interno di un elaboratore (computer), la font, è implementata come un unico file di dati digitali contenente un’insieme di caratteri tipografici di uno stesso tipo. Inizialmente il termine veniva utilizzato per definire l’insieme dei caratteri mobili (tecnologia di stampa che utilizza componenti mobili per la riproduzione su foglio di carta) in un unico stile e dimensione; ma a partire dagli anni novanta del ventesimo secolo viene impiegato per precisare un’insieme di forme digitali in un unico stile, scalabili in differenti dimensioni.<br>
								<br>
								Al giorno d’oggi esistono tre formati delle font, nonché bitmap font, vector font e stroke font.
								Le font sono progettate e create utilizzando editor font, nonché software applicativi utilizzati per la realizzazione e/o modifica. Le font appositamente progettate per essere utilizzate su schermo sono note come screens font. <br>
								<br>
								Le font possono essere monospaced (ogni carattere viene tracciato ad una distanza costante dal carattere precedente a cui si trova accanto) o proporzionali (ogni carattere ha la sua larghezza). Tuttavia, la particolare applicazione di gestione dei caratteri può influenzare la spaziatura, in particolare quando si effettua la giustificazione del testo.</p>
							</div>	
						</div>	
			</div>

				<!-- close capitolo-computer -->

				<hr class="hr1px">

				<!-- open capitolo-bitmap -->

			<div class="capitolo"> 
				<a name="bitmap">	
					<p class="titolo-capitolo" id="titolo_bitmap">Bitmap font</p>
				</a>	
						<div class="testo-capitolo" id="testo_bitmap">
							<div class="titolo-testo-capitolo">
								<p>Le matrici di pixel</p>
							</div>
							<div class="paragrafo-testo-capitolo">
								<p>Il formato bitmap font è comunemente chiamato anche raster font, è un sistema che memorizza ogni glifo come una matrice di pixel. Questo formato è possibile definirlo come una raccolta di raster images di glifi. Per ogni variante della font esiste un set completo di glifi e ogni set contiene un’immagine per ogni carattere. <br>
								<br>	
								Il formato bitmap font è estremamente veloce e semplice da creare rispetto ad altri ed è ideale per i display di qualità molto bassa, o di dimensioni ridotte, in cui la font deve essere ottimizzata per essere visualizzata in modo chiaro. Lo svantaggio principale è che la qualità visiva tende ad essere scarsa quando viene ridimensionata e/o trasformata. <br>
								<br>
								I bitmap font possono utilizzare la monocromia o le sfumature di grigio. Quest’ultimo viene definito come anti-aliased (una tecnica per minimizzare la risoluzione quando gli artefatti vengono distorti). Quando il testo viene visualizzato il sistema operativo rappresenta correttamente le “sfumature di grigio” come colori intermedi tra il colore del carattere e quello dello sfondo. Tuttavia, se il testo dovesse essere rappresentato con un’immagine di sfondo trasparente, le sfumature di grigio richiedono un formato differente dell’immagine che consenta l’alpha compositing, nonché il processo di creazione dell’aspetto della trasparenza.<br>
								<br>
								La differenza tra bitmap font e vector font è la memorizzazione dei dati. Il primo formato memorizza i dati dell’immagine come una griglia di pixel, il secondo formato memorizza i dati sotto forma di linee e curve.</p>
							</div>	
						</div>	
			</div>

				<!-- close capitolo-bitmap -->

				<hr class="hr1px">

				<!-- open capitolo-vector -->

			<div class="capitolo"> 
				<a name="vector">	
					<p class="titolo-capitolo" id="titolo_vector">Vector font</p>
				</a>	
						<div class="testo-capitolo" id="testo_vector">
							<div class="titolo-testo-capitolo">
								<p>Le immagini vettoriali</p>
							</div>
							<div class="paragrafo-testo-capitolo">
								<p>Il formato vector font, o outline fonts, è l’insieme di collezioni di immagini vettoriali, costituite da linee e curve che definiscono il confine dei glifi. I primi vector font venivano utilizzati dai vector monitors e vector plotters che utilizzavano i propri font interni, solitamente tratti sottili invece di spessi glifi delineati.<br>
								<br>
								L’avvento dell’editoria ha portato la ricerca di uno standard universale per integrare l’interfaccia utente grafica delle prime stampanti macintosh e laser. Il termine per descrivere la tecnologia di integrazione era WYSIWYG (what you see is what you get), un sistema in cui il software di editing permette di modificare il contenuto in una forma che assomiglia al suo aspetto quando viene stampato o visualizzato come prodotto finito. Il linguaggio universale era, ed è tuttora, Adobe PostScript. Alcuni formati di PostScript sono “Type 1” e “Type 3”, “TrueType” e “OpenType”.<br>
								<br>
								Il vantaggio principale dei vector fonts è che, a differenza dei bitmap fonts, sono un insieme di linee e curve invece che di pixel; possono essere scalati senza causare pixellation. Pertanto, i caratteri dei vector fonts possono essere scalati in qualsiasi dimensione e trasformati.<br>
								<br>
								Type 1 e Type 3 sono stati sviluppati da Adobe per la composizione digitale professionale. Il formato Type 1 è stato limitato a un sottoinsieme del linguaggio PostScript e hanno utilizzato il sistema di Adobe molto costoso. Lo standard Type 3 consentiva l’uso illimitato del linguaggio PostScript, ma non includeva alcuna informazione di suggerimento, che poteva portare ad artefatti di rendering visibili su dispositivi a bassa risoluzione (come schermi di computer e stampanti a matrice di punti).<br>
								<br>
								TrueType è uno standard delle outline fonts sviluppato da Apple alla fine degli anni ottanta come concorrente dei “Type 1 fonts” di Adobe. È diventato il formato più comune per le font sui classici sistemi operativi Mac OS, macOS e Microsoft Windows.
								Il punto di forza principale di TrueType era originariamente quello di offrire, agli sviluppatori delle font, un alto grado di controllo su come le loro font vengono visualizzate con precisione.<br>
								<br>
								OpenType è un formato per caratteri ridimensionabili. È stato costruito sul suo predecessore TrueType, mantenendo la struttura di base e aggiungendo molte strutture di dati intricate alla regole del comportamento tipografico. OpenType è un marchio registrato di Microsoft Corporation.
								A causa dell’ampia disponibilità e della flessibilità tipografica, il formato, comprese le posizioni per gestire i diversi comportamenti di tutti i sistemi di scrittura del mondo.</p>
							</div>	
						</div>	
			</div>

				<!-- close capitolo-vector -->

				<hr class="hr1px">

				<!-- open capitolo-stroke -->

			<div class="capitolo"> 
				<a name="stroke">	
					<p class="titolo-capitolo" id="titolo_stroke">Stroke font</p>
				</a>	
						<div class="testo-capitolo" id="testo_stroke">
							<div class="titolo-testo-capitolo">
								<p>Le linee</p>
							</div>
							<div class="paragrafo-testo-capitolo">
								<p>Il formato stroke font utilizza una serie di specifiche linee e aggiuntive informazioni per definire il profilo, o dimensione, e la forma di una specifica faccia, i quali definiscono e descrivono l’aspetto del glifo. Uno dei vantaggio del formato stroke font è proprio quello di ridurre il numero dei vertici necessari per definire un glifo, così permettendo di utilizzare gli stessi vertici per generare una font differente.<br>
								<br>	
								Un formato apparente alla famiglia dei formati stroke font è il linguaggio di descrizione Metafont. Il linguaggio Metafont è anche il nome dell’interprete che esegue e scrive il codice. Metafont è stato ideato da Donald Knuth come contropartita al suo sistema di composizione Tex. Una delle particolarità di Metafont è che tutte le forme dei glifi sono definite da equazioni geometriche.</p>
							</div>	
						</div>	
			</div>

				<!-- close capitolo-stroke -->

				<hr class="hr5px">

			<div class="indice">
				<p class="testo-indice">Sitografia</p>
			</div>	

				<hr class="hr1px">

			<div class="footer">
					<p class="footer-sitografia">
						Font •
							<a class="link-sitografia" href="https://en.wikipedia.org/wiki/Font" target="_blank">
								“Wikipedia.org”
							</a><br>

						Computer font •
							<a  class="link-sitografia"  href="https://en.wikipedia.org/wiki/Computer_font" target="_blank">
								“Wikipedia.org”
							</a><br>
						Bitmap font •
							<a  class="link-sitografia"  href="https://en.wikipedia.org/wiki/Computer_font#Bitmap_fonts" target="_blank">
								“Wikipedia.org”
							</a><br>

						Vector font •
							<a  class="link-sitografia"  href="https://en.wikipedia.org/wiki/Computer_font#Outline_fonts" target="_blank">
								“Wikipedia.org”
							</a><br>

						Stroke font •
							<a  class="link-sitografia"  href="https://en.wikipedia.org/wiki/Computer_font#Stroke-based_fonts" target="_blank">
								“Wikipedia.org”
							</a><br>
					</p>
			</div>	

				<hr class="hr5px">

			<div class="indice">
				<p class="testo-indice">Colophon</p>
			</div>	

				<hr class="hr1px">

			<div class="footer">
					<p class="footer-colophon">
						Atlante Tecnologico<br>
						“Font”<br>
						Luca Grisoni<br>
						SUPSI<br>
						Corso di Interaction Design • 2019/2020<br>
						Docenti: Andreas Gysin • Giovanni Profeta<br>
					</p>

				<a href="#arrow" class="footer-arrow">	
					<p>
						↑
					</p>
				</a>	
			</div>	


				<script type="text/javascript">
				
					var bottoni = document.getElementsByClassName("titolo-capitolo");

					for (var i = 0; i < bottoni.length; i++) {
						
							bottoni[i].addEventListener("click",  function(e){

								var id = e.target.id
								var capitolo =  id.replace("titolo_","")
								var nome_capitolo = "testo_" + capitolo
								var mio_testo = document.getElementById(nome_capitolo);

								var acceso = mio_testo.style.display

									if(acceso == "block"){
									mio_testo.style.display = "none"
									}

									else{
									mio_testo.style.display = "block"
									}
							})
					}


				var ss = {
				  fixAllLinks: function() {

				    var allLinks = document.getElementsByTagName('a');

				    for (var i=0;i<allLinks.length;i++) {
				      var lnk = allLinks[i];
				      if ((lnk.href && lnk.href.indexOf('#') != -1) && 
				          ( (lnk.pathname == location.pathname) ||
					    ('/'+lnk.pathname == location.pathname) ) && 
				          (lnk.search == location.search)) {
				 
				        ss.addEvent(lnk,'click',ss.smoothScroll);
				      }
				    }
				  },

				  smoothScroll: function(e) {
			
				    if (window.event) {
				      target = window.event.srcElement;
				    } else if (e) {
				      target = e.target;
				    } else return;

				    if (target.nodeName.toLowerCase() != 'a') {
				      target = target.parentNode;
				    }
				  
				    if (target.nodeName.toLowerCase() != 'a') return;
				  
				    anchor = target.hash.substr(1);

				    var allLinks = document.getElementsByTagName('a');
				    var destinationLink = null;
				    for (var i=0;i<allLinks.length;i++) {
				      var lnk = allLinks[i];
				      if (lnk.name && (lnk.name == anchor)) {
				        destinationLink = lnk;
				        break;
				      }
				    }
				  
				    if (!destinationLink) return true;

				    var destx = destinationLink.offsetLeft; 
				    var desty = destinationLink.offsetTop;
				    var thisNode = destinationLink;
				    while (thisNode.offsetParent && 
				          (thisNode.offsetParent != document.body)) {
				      thisNode = thisNode.offsetParent;
				      destx += thisNode.offsetLeft;
				      desty += thisNode.offsetTop;
				    }
				  
				    clearInterval(ss.INTERVAL);
				  
				    cypos = ss.getCurrentYPos();
				  
				    ss_stepsize = parseInt((desty-cypos)/ss.STEPS);
				    ss.INTERVAL =
				setInterval('ss.scrollWindow('+ss_stepsize+','+desty+',"'+anchor+'")',10);
				  
				    if (window.event) {
				      window.event.cancelBubble = true;
				      window.event.returnValue = false;
				    }
				    if (e && e.preventDefault && e.stopPropagation) {
				      e.preventDefault();
				      e.stopPropagation();
				    }
				  },

				  scrollWindow: function(scramount,dest,anchor) {
				    wascypos = ss.getCurrentYPos();
				    isAbove = (wascypos < dest);
				    window.scrollTo(0,wascypos + scramount);
				    iscypos = ss.getCurrentYPos();
				    isAboveNow = (iscypos < dest);
				    if ((isAbove != isAboveNow) || (wascypos == iscypos)) {

				      window.scrollTo(0,dest);

				      clearInterval(ss.INTERVAL);
		
				      location.hash = anchor;
				    }
				  },

				  getCurrentYPos: function() {
				    if (document.body && document.body.scrollTop)
				      return document.body.scrollTop;
				    if (document.documentElement && document.documentElement.scrollTop)
				      return document.documentElement.scrollTop;
				    if (window.pageYOffset)
				      return window.pageYOffset;
				    return 0;
				  },

				  addEvent: function(elm, evType, fn, useCapture) {

				    if (elm.addEventListener){
				      elm.addEventListener(evType, fn, useCapture);
				      return true;
				    } else if (elm.attachEvent){
				      var r = elm.attachEvent("on"+evType, fn);
				      return r;
				    } else {
				      alert("Handler could not be removed");
				    }
				  } 
				}

				ss.STEPS = 25;

				ss.addEvent(window,"load",ss.fixAllLinks);

				</script>
				
				<script src="../common/common.js" type="module"></script>

	</body>
</html>
